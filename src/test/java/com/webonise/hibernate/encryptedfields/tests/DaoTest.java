package com.webonise.hibernate.encryptedfields.tests;

import com.webonise.hibernate.encryptedfields.*;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.Base64;

import static org.junit.Assert.*;

/**
 * Created by Cesar Valverde on 6/30/2015.
 */
public class DaoTest {

    private static SecretKeySpec secretKey = null;
    private static String AES_PADDING = "AES/ECB/PKCS5Padding";
    private static String AlGORITHM = "AES";

    /**
     * Set up the test variables
     * @throws UnsupportedEncodingException
     * @throws NoSuchAlgorithmException
     */
    @BeforeClass
    public static void setUp() throws UnsupportedEncodingException, NoSuchAlgorithmException, SQLException {

        ProjectProperties projectProperties = new ProjectProperties();

        //ProjectProperties is required
        assertNotNull(projectProperties);

        //read secret key from a properties
        String keyFromProperties  = projectProperties.readProperty(ProjectProperties.AES_KEY);

        //Set up key
        byte[] key = keyFromProperties.getBytes(StandardCharsets.UTF_8);
        MessageDigest sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16); // use only first 128 bit
        secretKey = new SecretKeySpec(key, AlGORITHM);

        //Create TestEntity table if it does not exist
        try(Connection con = JDBC_Connection.getConnection()){
            String sql = "CREATE TABLE IF NOT EXISTS TestEntity " +
                    "(id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
                    " field VARCHAR(500))";
            try (Statement stmt = con.createStatement()) {
                stmt.executeUpdate(sql);
                stmt.close();
                con.close();
            }
        }
    }

    /**
     * Using Hibernate only
     */
    @Test
    public void testInsertAndRead() {

        String testString = "Test String";

        // Insert Entity1 using Hibernate
        TestEntity testEntity1 = new TestEntity();
        testEntity1.setField(testString);
        assertNull(testEntity1.getId());
        Dao dao = new Dao();
        dao.beginTransaction();
        dao.insertObject(testEntity1);

        //Make sure is id is not null
        assertNotNull(testEntity1.getId());
        dao.commitTransaction();

        // Read entity2 and compare with entity1
        dao = new Dao();
        dao.beginTransaction();
        TestEntity testEntity2 = (TestEntity) dao.findObjectById(TestEntity.class, testEntity1.getId());

        //Compare not same object
        assertNotSame(testEntity1, testEntity2);

        //Compare fields
        assertEquals(testEntity2.getField(), testEntity1.getField());

    }

    /**
     Save entity with hibernate
     and get the column with JDBC
     */
    @Test
    public void testInsertAndReadManually() throws SQLException, NoSuchAlgorithmException, BadPaddingException, NoSuchPaddingException, IllegalBlockSizeException, InvalidKeyException {

        String testString = "Test String";

        // Insert Entity
        TestEntity testEntity = new TestEntity();
        testEntity.setField(testString);
        assertNull(testEntity.getId());

        Dao dao = new Dao();
        dao.beginTransaction();
        dao.insertObject(testEntity);
        assertNotNull(testEntity.getId());

        dao.commitTransaction();

        /*
            Read and compare using JDBC
         */

        //Get a connection to the database
        try (Connection con = JDBC_Connection.getConnection()) {

            //Connection is required
            assertNotNull(con);

            //Get column from the database directly
            String column = null;
            String query = "select * from " + TestEntity.TABLE + " where id=" + testEntity.getId();
            try (Statement stmt = con.createStatement()) {
                ResultSet rs = stmt.executeQuery(query);
                while (rs.next()) {
                    column = rs.getString(TestEntity.FIELD);
                }
                stmt.close();
                con.close();
            }

            //Column is required
            assertNotNull(column);

            //secretKey is required
            Assert.assertNotNull(secretKey);

            //Decrypt
            String decryptedColumn = manualCipherDecrypt(base64Decode(column));

            //decryptedColumn is required
            Assert.assertNotNull(decryptedColumn);

            //Compare
             assertEquals(decryptedColumn, testEntity.getField());

        }

    }

    /**
     Save entity with JDBC
     and get the column with Hibernate
     */
    @Test
    public void testInsertAndReadManually2() throws SQLException, IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, UnsupportedEncodingException {

        String testString = "Test String";

        //Get a connection to the database
        try(Connection con = JDBC_Connection.getConnection()){

            //secretKey is required
            Assert.assertNotNull(secretKey);

            //Encrypted and base64 encoded
            String encryptedColumn = base64Encode(manualCipherEncrypt(testString));

            //encryptedColumn is required
            Assert.assertNotNull(encryptedColumn);

            //Insert column to the database directly
            String sql = "INSERT INTO " + TestEntity.TABLE + " (" + TestEntity.FIELD + ") VALUES ('" + encryptedColumn + "')";
            try(Statement stmt = con.createStatement()){
                stmt.executeUpdate(sql);
                stmt.close();
                con.close();
            }

            //Get last added entity
            Dao dao = new Dao();
            dao.beginTransaction();
            TestEntity testEntity = (TestEntity) dao.findLastObject(TestEntity.TABLE, TestEntity.FIELD);

            //testEntity is required
            Assert.assertNotNull(testEntity);

            //Compare
            assertEquals(testString, testEntity.getField());

        }

    }

    /**
     * Test of the formula to calculate the size of the cipher text in the database
     */
    @Test
    public void definedSizeTest() throws IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException {

        String testString = "00000000000000000000000000000000";

        System.out.println("Text size: " + testString.length());

        //secretKey is required
        Assert.assertNotNull(secretKey);

        /*
            Using AES algorithm
         */
        byte[] encryptedText = manualCipherEncrypt(testString);
        int encryptedTextSize = encryptedText.length;
        System.out.println("Encrypted Text size: " + encryptedTextSize);

        String encodedText = base64Encode(encryptedText);
        int encodedTextSize = encodedText.length();
        System.out.println("Encoded Text size: " + encodedTextSize);

        /*
            Using Formula
         */
        int calcEncryptedTextSize = calcSizeCipherText(testString.length());
        System.out.println("Calculated Encrypted Text size: " + calcEncryptedTextSize);

        int calcEncodedTextSize = calcSizeCipherTextBase64Encoded(encryptedText.length);
        System.out.println("Calculated Cipher Base64 Encoded Text size: " + calcEncodedTextSize);

        //Must be the same
        Assert.assertEquals(encryptedTextSize, calcEncryptedTextSize);

        //Must be the same
        Assert.assertEquals(encodedTextSize, calcEncodedTextSize);

    }

    public int calcSizeCipherText(int textSize){
        return textSize + 16 - (textSize%16);
    }

    public int calcSizeCipherTextBase64Encoded(int numBytes){
        return (numBytes + 2 - ((numBytes + 2) % 3)) / 3 * 4;
    }

    /**
     * @param text to decode
     * @return decoded bytes
     */
    public byte[] base64Decode(String text){
        return Base64.getDecoder().decode(text);
    }

    /**
     * @param text to encode
     * @return Base64 encoded String
     */
    public String base64Encode(byte[] text){
        return Base64.getEncoder().encodeToString(text);
    }

    /**
     * @param textBase64Encoded
     * @return the decrypted text
     */
    public String manualCipherDecrypt(byte[] textBase64Encoded) throws InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance(AES_PADDING);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        return new String(cipher.doFinal(textBase64Encoded), StandardCharsets.UTF_8);
    }

    /**
     * @param text to encrypt
     * @return Encrypted text
     */
    public byte[] manualCipherEncrypt(String text) throws BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        Cipher cipher = Cipher.getInstance(AES_PADDING);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return cipher.doFinal((text).getBytes(StandardCharsets.UTF_8));
    }


}